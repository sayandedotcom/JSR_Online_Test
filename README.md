<p align='center'><img src="https://user-images.githubusercontent.com/59247285/232352675-3717f79c-f39d-420a-8222-13a4bd5c7ae8.jpg"
 width="150" ></p>
<h1 align='center'> JSR Online Exam</h1>
[Live Link](https://online-test-one.vercel.app/)  

<p align='center'>
Online test proctoring refers to the use of technology to monitor and supervise students taking tests or exams remotely. It is a way to prevent cheating and maintain the integrity of online assessments.

Online test proctoring involves using software or tools that enable a proctor or invigilator to observe and monitor students while they take tests remotely. The proctor can view the test-taker's screen, webcam, and microphone to ensure that the test is taken in a secure and fair manner.

Some common features of online test proctoring tools include:

Webcam monitoring: The proctor can see the test-taker's face and surroundings to ensure that no one else is present in the room or attempting to assist the test-taker.
Screen sharing: The proctor can view the test-taker's screen to ensure that they are not using any unauthorized materials or accessing other websites or programs during the test.
Audio monitoring: The proctor can listen to the test-taker's microphone to ensure that they are not receiving any assistance or collaborating with others during the test.
Online test proctoring is often used in educational institutions and professional certification programs to ensure that exams are taken fairly and honestly, even when students are not physically present in the same location as the proctor or instructor. <br/> <br/>
In addition to that, we conducted a survey among our teachers where we found that teachers give more than 40% of their time to creating questions for various class tests, assignments and exams. So this teacher's day, we wanted to help them out. For this, we came up with crowdsourcing question bank idea. Anyone across the world can now help teachers make questions. <br/> <strong>By everyone, for teachers!‚ù§</strong>
</p>

<img width="1327" alt="playground user interface" src="https://user-images.githubusercontent.com/67703407/132119834-68cd31ee-179a-4cff-80b1-d2979fb87146.png">

## What is it? ‚õπÔ∏è‚Äç‚ôÇÔ∏è
There are two subsystems of the Playground:
1. Evaluation of answer sheets of the exams conducted traditionally is a tedious and critical task. A lot of time and energy is invested by the teachers to check every single line of code, look for bugs and find the corresponding output. So, with Playground, you can simply upload a picture of a student's handwritten code and we will handle the rest. Using Google's Vision API, we scan the image and retrieve the text and give it back to you in a code editor. But unlike teachers, machines are not always right, so if some minor flaws are there you can edit them in the code editor, which will then run the code and give you the output. So instead of going through the entire code, use Playground to do it in less than 2 mins.
2. Teachers have to work hard everyday. Starting from explaining the concepts in a pace all students understand, to giving proper assignments, to clearing all the doubts. So we thought let us make another important job for our teachers super easy. With Playground, you can also easily create question papers and assignments for your students. This is done by crowdsourcing. Students and teachers across the world can add their favourite questions through a form and then you'll get a variety of coding questions which are pre-approved by us. So just select some of the random questions from our page and you're done with the assignment! It's that simple!


### Table of Contents

| No. | Questions                                                                                        |
| --- | ------------------------------------------------------------------------------------------------ |
| 1   | [Our respective problem statement.](#our-respective-problem-statement)                           |
| 2   | [Our team name and details](#our-team-name-and-details)                                          |
| 3   | [Our idea and approach used in implementing it.](#our-idea-and-approach-used-in-implementing-it) |
| 4   | [Mention the tech stack you are using.](#mention-the-tech-stack-you-are-using)                   |
| 5   | [Deployed Live Link](#deployed-Live-Link)                                                        |

### 1. Our respective problem statement

### 2. Our team name and details

| Name                  | Roles                 | GitHub                                      | Email                                   |
| --------------------- | --------------------- | ------------------------------------------- | --------------------------------------- |
| Ayan De (Team Leader) | Back-End Development  | [Ayan](https://github.com/ayan-de)          | [Ayan](mailto:deayan252@gmail.com)      |
| Sayan De              | Front-End Development | [Sayan](https://github.com/sayande2002)     | [Sayan](mailto:sayandeten@gmail.com)    |
| Ujjal Manna           | UI Development        | [Ujjal](https://github.com/UJJALMANNA)      | [Ujjal](mailto:mannaujjal683@gmail.com) |
| Sovan Bakshi          | UX Development        | [Sovan](https://github.com/sovanbakshi2004) | [Sovan](mailto:bakshisovan1@gmail.com)  |

### 3. Our idea and approach used in implementing it

### 4. Mention the tech stack you are using

## üìå Main Technologies used üõ†Ô∏è

- [MongoDB](https://reactjs.org) - Database
- [ExpressJS](https://reactjs.org) - NodeJs Framework
- [ReactJS](https://reactjs.org) - Javascript library for Front-End
- [NodeJS](https://reactjs.org) - Javascript library for Back-End
- [Mongoose](https://reactjs.org) - MongoDB Framework

## üìå Other Front-End Libraries used üõ†Ô∏è

- [react-router-dom](https://www.npmjs.com/package/react-router) - Used for Routing
- [TailwindCSS](https://tailwindcss.com/) - Used for Styling in CSS
- [react-hook-form](https://www.npmjs.com/package/react-hook-form) - Used for form handling
- [hookform/resolvers](https://www.npmjs.com/@hookform/resolvers) - Used for form validation
- [react-timer-hook](https://www.npmjs.com/react-timer-hook) - Used for timer clok
- [react-tippy](https://www.npmjs.com/react-tippy) - Used for tooltip
- [react-toastify](https://www.npmjs.com/react-toastify) - Used for toast notifications
- [yup](https://www.npmjs.com/yup) - Used for form validation

## üìå Other Back-End Libraries used üõ†Ô∏è

- [cookie-parser](https://www.npmjs.com/cookie-parser) - Used for parsing cookie token
- [cookie-session](https://www.npmjs.com/cookie-session) - Used for handling cookie
- [cors](https://www.npmjs.com/cors) - Used for handling cors error
- [dotenv](https://www.npmjs.com/dotenv) - Used for handling dotenv file
- [jsonwebtoken](https://www.npmjs.com/jsonwebtoken) - Used to generate cookie
- [morgan](https://www.npmjs.com/morgan) - Used to see requests in console.log
- [validator](https://www.npmjs.com/validator) - Used for form validation

### 5. Deployed Live Link

[Visit Website](https://sayande.tech/)

## üìå Sneak Peek of Main Page:

<div align="center" style="
    flex-wrap: wrap;
    display: flex;
    gap: 1rem;
">
<h1> Startup Page</h1>
  <img src="![Screenshot (249)](https://user-images.githubusercontent.com/107565578/232357619-18854421-12b7-4b11-9986-2ff0cf7e9d4b.png)
" alt="Home Page" width="70%">


## üìå Getting Started üöÄ

These instructions will get you a copy of the project up and running on your local machine for development and testing purposes.

# Prerequisites üìã

You'll need [Git](https://git-scm.com) and [Node.js](https://nodejs.org/en/download/) (which comes with [NPM](http://npmjs.com)) installed on your computer.


node@v10.16.0 or higher
npm@6.9.0 or higher
git@2.17.1 or higher


From your command line, first clone this repo:

bash
# Clone this repository
$ git clone https://github.com/sayande2002/JSR_Online_Test

# Go into the repository
$ cd JSR_Online_Test

# Remove current origin repository
$ git remote remove origin


Then you can install the dependencies either using NPM or Yarn:

Using NPM:

bash
# Install dependencies
$ npm install

# Start development server
$ npm start


Once your server has started, go to this url `http://localhost:3000/` and you will see the website running on a Development Server.


## Connecting to the Database
Spin up your cluster in MongoDB and replace your connection with URI in `.env`
If you face any problems, refer to the [MongoDB](https://www.mongodb.com/blog/postquick-start-nodejs-mongodb--how-to-get-connected-to-your-database) website.


## Connecting to the Database if you haven't used MongoDB Atlas before
Install the MongoDB Node.js Driver with the following command:
bash
npm install mongodb


Set up a [MongoDB Atlas Database](https://www.youtube.com/watch?v=rPqRyYJmx2g) by following this short MongoDB setup video till the 3:20 mark. Stop after that mark!

On your Cluster home page, select CONNECT > Connect your application. 
1. Select Node.js in the drop down for your driver, and select the latest version. 
1. Then, copy the connecting string (URI).
1. Paste this string as the value of mongoURI inside `.env` of this project.

Replace the `<password>` section of the string with your Database Access password. Viola, your server should now successfuly connect to MongoDB!
## How we built it üßë‚Äçüíª
We used React.js in the frontend and Node.js in the backend with MongoDB as our database.The question by the admin was given through postman was displayed in a exam app along with the options of the questions. When we click submit, we send the data(array of answers) from react fromntend to the backend and then in the backend we parse it and compare it with the array of correct answers. Then on basis of the comparison we generate a marks which is then sent to the frontend to display user their result.

## Challenges we ran into ü•∫
We faced numerours challenges throughout the journey. Firstly, we had to look for a good DRM model. We checked so many github repositories and packages but we couldn't find a one that had very high efficiency. So we finally decided to go with creating a system which could stop users from cheating during exam by capturing screenshots, we basically end up with such idea when we looked into deeeper into how mirroring works( continuous screenshots at very small intervals). We saw that while development, we had already used up so many different api (face-=api.js etc) which affects the main functionality of our code so we end us discarding such things. Other than that we tried creating our very own anti screenshot system(detect right click) for the first time, which were initailly full of bugs and it took us a lot of time to fix them.

## Accomplishments that we're proud of üòé
The biggest accomplishment for us was that we learned so many new things in just 2 days. We implemented proctoring system, deploying, fetch and API calls. We were able to overcome all the challenges and were able to create a completely functional prototype the way we had envisioned. Even though one of our teammates fell sick and wasn't able to contribute, we didn't lose hope and stayed up all night. It was tiring, but fun as well. I am most proud of the fact that this product will be able to help many teachers across the globe.

## Built With üíï
- [ ] React
- [ ] Nodejs
- [ ] Javascript
- [ ] Express
- [ ] MongoDB
- [ ] Mongoose
- [ ] Face-Api.js
- [ ] Vercel

<img src='https://challengepost-s3-challengepost.netdna-ssl.com/photos/production/challenge_photos/001/637/595/datas/full_width.png' />
